<template>
  <div class="chat-wrapper h-full">
    <!-- ÈõÜÊàêÁ≥ªÁªüÂ§¥ÈÉ® -->
    <header class="bg-[#2A5C8A] text-white shadow-md">
      <div class="container mx-auto px-4">
        <div class="flex items-center h-16">
          <button @click="router.back()" class="mr-2 lg:hidden">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
            </svg>
          </button>
          <div class="flex items-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="m8 3 4 8 5-5 5 15H2L8 3z"/>
            </svg>
            <span class="ml-2 font-bold text-xl">AIÂøÉÁêÜÂí®ËØ¢</span>
          </div>
        </div>
      </div>
    </header>

    <!-- ‰∏ªËÅäÂ§©Âå∫Âüü -->
    <main class="flex-1 bg-gray-50 overflow-hidden h-[calc(100vh-64px)]" @click.stop>
      <div class="h-full flex flex-col">
        <!-- ËÅäÂ§©ÂÜÖÂÆπÂå∫Âüü -->
        <div ref="chatContainer" class="flex-1 overflow-y-auto p-4 space-y-6">
          <!-- Ê¨¢ËøéÊ∂àÊÅØ -->
          <div class="welcome-message bg-blue-50 border border-blue-100 rounded-lg p-6 mb-6 max-w-3xl mx-auto shadow-sm">
            <div class="flex items-start gap-4">
              <a-avatar :size="48" src="/src/assets/imgs/logo.png" class="flex-shrink-0" />
              <div v-html="configInfo.notice_html_wdms" class="prose"></div>
            </div>
          </div>

          <!-- ËÅäÂ§©ËÆ∞ÂΩï -->
          <div v-for="(conv, idx) in getCurrentConversation" 
               :key="idx"
               :class="['message-wrapper', { 'justify-end': conv.speaker === 'human' }]">
            <div :class="['message-bubble', conv.speaker, { 'ml-auto': conv.speaker === 'human' }]">
              <div class="avatar">
                <a-avatar
                  :size="40"
                  :src="conv.speaker === 'ai' ? '/src/assets/imgs/logo.png' : '/src/assets/imgs/human1.png'"
                />
              </div>
              <div class="message-content">
                <div class="message-body">
                  <!-- Ê∑ªÂä†Ë∞ÉËØï‰ø°ÊÅØ -->
                  <div v-if="conv.speaker === 'ai'" class="ai-message">
                    <!-- Ê∑ªÂä†ÂéüÂßãÊñáÊú¨ÊòæÁ§∫ÔºåÁî®‰∫éË∞ÉËØï -->
                    <div class="debug-text text-xs text-gray-400 mb-1" v-if="false">
                      ÂéüÂßã: {{ getMessageText(conv) }}
                    </div>
                    
                    <!-- Ê≠£Â∏∏Ê∏≤Êüì -->
                    <div v-html="mdToHtml(getMessageText(conv))" class="prose max-w-none"></div>
                  </div>
                  <div v-else>{{ conv.speech }}</div>
                </div>
                <div class="message-actions">
                  <a-tooltip title="Â§çÂà∂" placement="bottom">
                    <CopyOutlined class="action-icon" @click="copyMessage(conv)" />
                  </a-tooltip>
                </div>
              </div>
            </div>
          </div>

          <!-- Âä†ËΩΩÁä∂ÊÄÅ -->
          <div v-if="convLoading" class="message-wrapper">
            <div class="message-bubble ai loading">
              <div class="avatar">
                <a-avatar :size="40" src="/src/assets/imgs/logo.png" />
              </div>
              <div class="message-content">
                <div class="typing-indicator">
                  <span></span>
                  <span></span>
                  <span></span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Â∫ïÈÉ®ËæìÂÖ•Âå∫Âüü -->
        <div class="bg-white border-t p-4 shadow-inner">
          <!-- ÂΩïÈü≥È¢ÑËßà -->
          <div v-if="audioUrl" class="audio-preview bg-gray-50 rounded-lg p-3 mb-3 flex items-center">
            <span class="text-sm text-gray-600 mr-3">üéß ÂΩïÈü≥È¢ÑËßà</span>
            <audio :src="audioUrl" controls class="flex-1"></audio>
            <button @click="clearRecording" class="ml-2 text-gray-500 hover:text-gray-700 focus:outline-none">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
              </svg>
            </button>
          </div>

          <!-- ËæìÂÖ•Ê°ÜÂíåÂèëÈÄÅÊåâÈíÆ -->
          <div class="input-container">
            <textarea
              v-model="chatMsg"
              @keydown="judgeInput"
              @input="adjustTextareaHeight"
              @focus="adjustTextareaHeight"
              ref="inputChat"
              placeholder="ÂêëAIÂøÉÁêÜÂí®ËØ¢Â∏àÂÄæËØâÊÇ®ÁöÑÊÉ≥Ê≥ïÔºåShift+EnterÊç¢Ë°åÔºåEnterÂèëÈÄÅ"
              class="chat-input w-full resize-none border border-gray-300 rounded-xl py-3 px-4 focus:border-blue-500 focus:ring-2 focus:ring-blue-200 transition-all"
              :maxlength="1000"
              rows="1"
            ></textarea>
            <button 
              class="send-button flex-shrink-0 w-12 h-12 bg-[#4a9be6] hover:bg-[#7c97ea] text-white rounded-xl flex items-center justify-center transition-all duration-200 disabled:bg-gray-300 disabled:cursor-not-allowed transform hover:-translate-y-0.5"
              @click="send"
              :disabled="convLoading || audioUpload"
            >
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/>
              </svg>
            </button>
          </div>

          <!-- Â∑•ÂÖ∑ÊåâÈíÆ -->
          <div class="tools-container mt-3">
            <div class="tool-buttons flex flex-wrap gap-2">
              <button 
                type="button" 
                @click="toggleRecording"
                :class="[
                  'tool-button flex items-center gap-1.5 px-3 py-2 rounded-lg border transition-all duration-200',
                  isRecording 
                    ? 'bg-red-50 border-red-200 text-red-600' 
                    : 'bg-white border-gray-300 hover:bg-gray-50 hover:-translate-y-0.5'
                ]"
                :disabled="audioUpload"
              >
                <span class="tool-icon">
                  <svg v-if="isRecording" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 10a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z" />
                  </svg>
                  <svg v-else class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                  </svg>
                </span>
                <span class="tool-text text-sm">{{ isRecording ? 'ÂÅúÊ≠¢ÂΩïÈü≥' : 'ÂºÄÂßãÂΩïÈü≥' }}</span>
                <span v-if="isRecording" class="recording-indicator w-2 h-2 bg-red-600 rounded-full animate-pulse"></span>
              </button>
              
              <button 
                type="button"
                @click="uploadAudio"
                :disabled="!audioBlob || audioUpload"
                :class="[
                  'tool-button flex items-center gap-1.5 px-3 py-2 rounded-lg border transition-all',
                  audioUpload 
                    ? 'bg-blue-50 border-blue-200 text-blue-600' 
                    : 'bg-white border-gray-300 hover:bg-gray-50',
                  (!audioBlob || audioUpload) ? 'opacity-60 cursor-not-allowed' : ''
                ]"
              >
                <span class="tool-icon">
                  <svg v-if="audioUpload" class="w-5 h-5 animate-spin" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                  </svg>
                  <svg v-else class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                  </svg>
                </span>
                <span class="tool-text text-sm">{{ audioUpload ? 'ËØÜÂà´‰∏≠...' : 'ËØÜÂà´ÂΩïÈü≥' }}</span>
              </button>
              
              <button 
                type="button"
                @click="analyzeEmotion"
                :disabled="convLoading"
                :class="[
                  'tool-button flex items-center gap-1.5 px-3 py-2 rounded-lg border transition-all',
                  'bg-blue-50 border-blue-200 text-blue-500 hover:bg-blue-100',
                  convLoading ? 'opacity-60 cursor-not-allowed' : ''
                ]"
              >
                <span class="tool-icon">
                  <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                </span>
                <span class="tool-text text-sm">ÊÉÖÁª™ÂàÜÊûê</span>
              </button>
            </div>
          </div>

          <!-- Âú®Â∑•ÂÖ∑ÊåâÈíÆÂå∫Âüü‰∏ãÊñπÊ∑ªÂä† -->
          <div v-if="lastVoiceEmotion && isDevelopment" class="debug-panel mt-2 p-2 bg-gray-100 rounded-lg text-xs text-gray-600">
            <div class="font-bold">ÊÉÖÁª™ÂàÜÊûêË∞ÉËØï‰ø°ÊÅØ:</div>
            <div>Ê£ÄÊµãÂà∞ÊÉÖÁª™: {{ lastVoiceEmotion.emotion }}</div>
            <div>ÁΩÆ‰ø°Â∫¶: {{ lastVoiceEmotion.confidence }}</div>
            <div>Èü≥È¢ëË¥®Èáè: {{ lastVoiceEmotion.quality }}</div>
            <div>Êó∂Èó¥Êà≥: {{ new Date(lastVoiceEmotion.timestamp).toLocaleTimeString() }}</div>
          </div>
        </div>
      </div>
    </main>
  </div>
</template>

<script>
import { marked } from 'marked';
import hljs from "highlight.js";
import 'highlight.js/styles/github.css';
import { mapGetters, mapActions, mapState } from 'vuex'
import { post } from '@/utils/request'
import Recorder from 'recorder-core'
import 'recorder-core/src/engine/mp3'
import 'recorder-core/src/engine/mp3-engine'
import 'recorder-core/src/engine/wav'
import 'recorder-core/src/extensions/waveview'
import { CopyOutlined } from '@ant-design/icons-vue'
import router from '@/router'
import axios from 'axios'
import { ElMessage } from 'element-plus'

// ÊáíÂä†ËΩΩ Recorder ÂÆû‰æãÔºåÂè™Âú®ÈúÄË¶ÅÊó∂ÂàõÂª∫
let recorder = null;
const initRecorder = () => {
  if (!recorder) {
    recorder = Recorder({
      type: 'wav',
      sampleRate: 16000,  // Á°Æ‰øù‰∏éPythonÊúçÂä°ÂåπÈÖç
      bitRate: 16,        // 16‰ΩçÊ∑±Â∫¶
      numChannels: 1,     // ÂçïÂ£∞ÈÅìÔºåÊõ¥ÈÄÇÂêàËØ≠Èü≥Â§ÑÁêÜ
      onProcess: (buffers, powerLevel, bufferDuration, bufferSampleRate) => {
        // ÂèØ‰ª•Âú®ËøôÈáåÂ§ÑÁêÜÂÆûÊó∂Èü≥È¢ëÊï∞ÊçÆ
        console.log("ÂΩïÈü≥Â§ÑÁêÜ‰∏≠ÔºåÈü≥Èáè:", powerLevel, "ÊåÅÁª≠Êó∂Èó¥:", bufferDuration);
      }
    });
  }
  return recorder;
};

// ‰ºòÂåñ marked Ê∏≤ÊüìÂô®Ôºå‰ΩøÁî®ÁºìÂ≠òÊèêÈ´òÊÄßËÉΩ
const rendererCache = new Map();
const renderer = {
  code(code, infostring, escaped) {
    const cacheKey = `${code}-${infostring}`;
    if (rendererCache.has(cacheKey)) {
      return rendererCache.get(cacheKey);
    }
    
    const codeHtml = infostring ? hljs.highlightAuto(code).value : code;
    const result = `<div class="code-block">
      <div class="code-header">
        <span>${infostring || ''}</span>
        <button class="copy-btn" data-code="${encodeURIComponent(code)}">
          <svg stroke="currentColor" fill="none" viewBox="0 0 24 24">
            <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
            <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
          </svg>
          <span>Â§çÂà∂‰ª£Á†Å</span>
        </button>
      </div>
      <pre><code class="hljs language-${infostring}">${codeHtml}</code></pre>
    </div>`;
    
    rendererCache.set(cacheKey, result);
    return result;
  },
  paragraph(text) {
    return `<p class="message-paragraph">${text}</p>`;
  }
};

// ÈôêÂà∂ÁºìÂ≠òÂ§ßÂ∞èÔºåÈÅøÂÖçÂÜÖÂ≠òÊ≥ÑÊºè
const MAX_CACHE_SIZE = 100;
const mdCache = new Map();

marked.use({ renderer });

export default {
  components: {
    CopyOutlined
  },
  data() {
    return {
      chatMsg: "",
      convLoading: false,
      configInfo: {
        notice_html_wdms: `
        <h3 class="text-lg font-semibold mb-2">Ê¨¢Ëøé‰ΩøÁî®AIÂøÉÁêÜÂí®ËØ¢ÊúçÂä°</h3>
        <p class="mb-2">ÊàëÊòØÊÇ®ÁöÑÂøÉÁêÜÂÅ•Â∫∑Âä©ÊâãÔºåÂèØ‰ª•‰∏∫ÊÇ®Êèê‰æõ:</p>
        <ul class="list-disc pl-5 space-y-1">
          <li>ÊÉÖÁª™ÊîØÊåÅÂíåÂøÉÁêÜÁñèÂØº</li>
          <li>ÂøÉÁêÜÂÅ•Â∫∑Áü•ËØÜÁßëÊôÆ</li>
          <li>ÁÆÄÂçïÁöÑËÆ§Áü•Ë°å‰∏∫ÁñóÊ≥ïÁªÉ‰π†</li>
          <li>ÂéãÂäõÁÆ°ÁêÜÂª∫ËÆÆ</li>
        </ul>
        <p class="mt-3 text-sm text-blue-600">ËØ∑Ê≥®ÊÑèÔºöAI‰∏çËÉΩÊõø‰ª£‰∏ì‰∏öÂøÉÁêÜÂí®ËØ¢ÔºåÂ¶ÇÊúâ‰∏•ÈáçÂõ∞Êâ∞ËØ∑ÂØªÊ±Ç‰∏ì‰∏öÂ∏ÆÂä©„ÄÇ</p>
        `,
      },
      audioBlob: null,
      audioUrl: null,
      isRecording: false,
      audioUpload: false,
      audioStream: null,
      waveView: null,
      recordingStartTime: null,
      recordingDuration: 0,
      recordingTimer: null,
      retryingMessage: false,
      networkStatus: navigator.onLine,
      lastVoiceEmotion: null,
      lastNetworkCheckFailed: false,
      cacheCleanupInterval: null,
      apiBaseUrl: '',
      isDevelopment: import.meta.env.DEV
    }
  },
  computed: {
    ...mapState(['currentConversationId']),
    ...mapGetters(['getCurrentConversation', 'isLoading'])
  },
  methods: {
    ...mapActions(['addConversationContent', 'loadConversations']),
    
    async init() {
      // Ê∑ªÂä†‰ª£Á†ÅÂùóÂ§çÂà∂ÂäüËÉΩ
      this.$nextTick(() => {
        document.addEventListener('click', (e) => {
          if (e.target.closest('.copy-btn')) {
            const code = decodeURIComponent(e.target.closest('.copy-btn').dataset.code);
            navigator.clipboard.writeText(code).then(() => {
              ElMessage.success('‰ª£Á†ÅÂ∑≤Â§çÂà∂');
            });
          }
        });
      });
    },
    
    async send() {
      const text = this.chatMsg.trim();
      this.chatMsg = '';

      if (!text || this.convLoading || this.audioUpload) return;

      await this.sendMessageWithRetry(text);
    },
    
    async sendMessage(msg) {
      if (!this.currentConversationId) {
        ElMessage.warning("ËØ∑ÂÖàÈÄâÊã©ÊàñÂàõÂª∫‰∏Ä‰∏™ÂØπËØù");
        return;
      }
      
      // Ê£ÄÊü•ÁΩëÁªúÁä∂ÊÄÅ
      if (!this.checkNetworkStatus()) return;
      
      this.addConversationContent({
        id: this.currentConversationId,
        content: {
          speaker: "human",
          speech: msg,
        }
      });

      let conv = {
        idx: 0,
        loading: true,
        speaker: "ai",
        suitable: [0],
        speeches: [""],
        speech: ""
      };

      this.handleScrollBottom();
      this.convLoading = true;

      try {
        const currentList = this.getCurrentConversation;
        const payload = {
          messages: currentList.slice(-6).map(item => ({
            "role": { ai: "assistant", human: "user" }[item.speaker],
            "content": item.speaker === "human" ? item.speech : (item.speeches && item.speeches[0] || "")
          }))
        };
        
        // Â¶ÇÊûúÊúâËØ≠Èü≥ÊÉÖÁª™ÂàÜÊûêÁªìÊûú‰∏î‰∏çË∂ÖËøá5ÂàÜÈíüÔºåÊ∑ªÂä†Âà∞ËØ∑Ê±Ç‰∏≠
        if (this.lastVoiceEmotion && 
            (Date.now() - this.lastVoiceEmotion.timestamp < 5 * 60 * 1000)) {
          // Ëß£ÊûêÁΩÆ‰ø°Â∫¶Â≠óÁ¨¶‰∏≤ÔºåÁßªÈô§ÁôæÂàÜÂè∑Âπ∂ËΩ¨Êç¢‰∏∫Êï∞ÂÄº
          let confidence = this.lastVoiceEmotion.confidence;
          if (typeof confidence === 'string' && confidence.endsWith('%')) {
            confidence = parseFloat(confidence.replace('%', '')) / 100;
          }
          
          // Á°Æ‰øùÊ†ºÂºè‰∏éÂêéÁ´ØÊúüÊúõÁöÑMap<String, Object>ÂåπÈÖç
          payload.voiceEmotion = {
            emotion: this.lastVoiceEmotion.emotion,
            confidence: confidence,
            quality: this.lastVoiceEmotion.quality
          };
        }
        
        // ‰ΩøÁî®Êõ¥ÈïøÁöÑË∂ÖÊó∂Êó∂Èó¥
        const response = await post("/business/chat/aiChat", payload, { timeout: 60000 });

        console.log("AIÂìçÂ∫îÂéüÂßãÊï∞ÊçÆ:", response);

        // Â§ÑÁêÜÂìçÂ∫î
        if (response && response.code === '200') {
          // ÁÆÄÂåñÂìçÂ∫îÂ§ÑÁêÜÈÄªËæë
          let aiResponse = "";
          
          if (typeof response.data === 'string') {
            aiResponse = response.data;
          } 
          else if (response.data && typeof response.data === 'object') {
            // Â∞ùËØïÊèêÂèñÂ∏∏ËßÅÂ≠óÊÆµ
            if (response.data.content) {
              aiResponse = response.data.content;
            } 
            else if (response.data.message && typeof response.data.message === 'string') {
              aiResponse = response.data.message;
            }
            else if (response.data.message && response.data.message.content) {
              aiResponse = response.data.message.content;
            }
            else if (response.data.choices && response.data.choices.length > 0) {
              const choice = response.data.choices[0];
              if (typeof choice === 'string') {
                aiResponse = choice;
              } 
              else if (choice.message && typeof choice.message === 'string') {
                aiResponse = choice.message;
              }
              else if (choice.message && choice.message.content) {
                aiResponse = choice.message.content;
              }
              else if (choice.text) {
                aiResponse = choice.text;
              }
            }
            else {
              // Â¶ÇÊûúÊó†Ê≥ïÊèêÂèñÔºåÂ∞ùËØïJSONÂ≠óÁ¨¶‰∏≤Âåñ
              try {
                aiResponse = JSON.stringify(response.data);
              } catch (e) {
                aiResponse = "Êó†Ê≥ïËß£ÊûêÁöÑÂìçÂ∫îÊ†ºÂºè";
              }
            }
          }
          
          // Á°Æ‰øùaiResponseÊòØÂ≠óÁ¨¶‰∏≤
          if (typeof aiResponse !== 'string') {
            aiResponse = String(aiResponse);
          }
          
          // Êõ¥Êñ∞ÂØπËØùÂÜÖÂÆπ
          conv.speeches[0] = aiResponse;
          conv.speech = aiResponse;
          
          this.addConversationContent({
            id: this.currentConversationId,
            content: {
              ...conv,
              loading: false
            }
          });
          
          this.handleScrollBottom();
        } else {
          // Â§ÑÁêÜÈîôËØØÂìçÂ∫î
          const errorMsg = response?.msg || response?.data?.message || "AIÂõûÂ§çÂ§±Ë¥•";
          ElMessage.error(errorMsg);
          
          // Âú®ËÅäÂ§©‰∏≠ÊòæÁ§∫ÈîôËØØÊ∂àÊÅØ
          conv.speeches[0] = `Êä±Ê≠âÔºåÈÅáÂà∞ÈóÆÈ¢ò: ${errorMsg}`;
          conv.speech = `Êä±Ê≠âÔºåÈÅáÂà∞ÈóÆÈ¢ò: ${errorMsg}`;
          this.addConversationContent({
            id: this.currentConversationId,
            content: conv
          });
        }
      } catch (error) {
        console.error("Error fetching chat response:", error);
        
        let errorMessage = "ËØ∑Ê±ÇÂ§±Ë¥•";
        if (error.message) errorMessage += `: ${error.message}`;
        if (error.response) errorMessage += ` (Áä∂ÊÄÅÁ†Å: ${error.response.status})`;
        
        ElMessage.error(errorMessage);
        
        // Âú®ËÅäÂ§©‰∏≠ÊòæÁ§∫ÈîôËØØÊ∂àÊÅØ
        conv.speeches[0] = "Êä±Ê≠âÔºåÊàëÈÅáÂà∞‰∫ÜÊäÄÊúØÈóÆÈ¢òÔºåÊó†Ê≥ïÂõûÂ∫îÊÇ®ÁöÑÊ∂àÊÅØ„ÄÇËØ∑Á®çÂêéÂÜçËØï„ÄÇ";
        conv.speech = "Êä±Ê≠âÔºåÊàëÈÅáÂà∞‰∫ÜÊäÄÊúØÈóÆÈ¢òÔºåÊó†Ê≥ïÂõûÂ∫îÊÇ®ÁöÑÊ∂àÊÅØ„ÄÇËØ∑Á®çÂêéÂÜçËØï„ÄÇ";
        this.addConversationContent({
          id: this.currentConversationId,
          content: conv
        });
      } finally {
        this.convLoading = false;
        conv.loading = false;
      }
    },
    
    stopChat() {
      this.convLoading = false;
    },
    
    mdToHtml(md) {
      console.log("ÂáÜÂ§áÊ∏≤ÊüìMarkdown:", md); // Ê∑ªÂä†Êó•Âøó
      
      if (!md) {
        console.warn("Êî∂Âà∞Á©∫ÁöÑMarkdownÂÜÖÂÆπ");
        return "<p>Êó†ÂÜÖÂÆπ</p>";
      }
      
      // Ê∑ªÂä†ÂÆâÂÖ®ËøáÊª§
      md = this.sanitizeMarkdown(md);
      
      // Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´MarkdownËØ≠Ê≥ï
      const hasMarkdown = /(\*\*|__|\*|_|~~|`|```|#|>|\[.*]\(.*\)|^\d+\.|^-|\+)/.test(md);
      
      // Â¶ÇÊûú‰∏çÂåÖÂê´MarkdownËØ≠Ê≥ïÔºåÁõ¥Êé•ËøîÂõûÁ∫ØÊñáÊú¨ÔºåÂè™Â§ÑÁêÜÊç¢Ë°å
      if (!hasMarkdown) {
        console.log("ÂÜÖÂÆπ‰∏çÂåÖÂê´MarkdownÔºåÁõ¥Êé•ËøîÂõûÁ∫ØÊñáÊú¨");
        // Â§ÑÁêÜÊç¢Ë°åÂíåÁ©∫Ê†º
        const htmlText = md
          .replace(/\n/g, '<br>')
          .replace(/\s\s/g, '&nbsp;&nbsp;');
        return `<p class="message-paragraph">${htmlText}</p>`;
      }
      
      // ‰ΩøÁî®ÁºìÂ≠òÊèêÈ´òÊÄßËÉΩ
      if (mdCache.has(md)) {
        return mdCache.get(md);
      }
      
      try {
        // Á°Æ‰øù‰ª£Á†ÅÂùóÈó≠Âêà
        const codeBlockCount = (md.match(/```/g) || []).length;
        if (codeBlockCount % 2 !== 0) {
          md += "\n```";
        }
        
        // Â∞ùËØïÁõ¥Êé•‰ΩøÁî®markedËß£Êûê
        const result = marked.parse(md.trim());
        
        // Ê£ÄÊü•ÁªìÊûúÊòØÂê¶ÂåÖÂê´[object Object]
        if (result.includes('[object Object]')) {
          console.warn("Ê∏≤ÊüìÁªìÊûúÂåÖÂê´[object Object]Ôºå‰ΩøÁî®Â§áÁî®Ê∏≤ÊüìÊñπÊ≥ï");
          // Â§áÁî®Ê∏≤ÊüìÊñπÊ≥ïÔºöÁÆÄÂçïÂú∞Â§ÑÁêÜÂ∏∏ËßÅÁöÑMarkdownËØ≠Ê≥ï
          return this.simpleMarkdownRender(md);
        }
        
        // ÈôêÂà∂ÁºìÂ≠òÂ§ßÂ∞è
        if (mdCache.size >= MAX_CACHE_SIZE) {
          const firstKey = mdCache.keys().next().value;
          mdCache.delete(firstKey);
        }
        
        mdCache.set(md, result);
        console.log("MarkdownÊ∏≤ÊüìÁªìÊûú:", result.substring(0, 100) + "..."); // Ê∑ªÂä†Êó•Âøó
        return result;
      } catch (error) {
        console.error("MarkdownÊ∏≤ÊüìÈîôËØØ:", error);
        // Â¶ÇÊûúÊ∏≤ÊüìÂ§±Ë¥•Ôºå‰ΩøÁî®Â§áÁî®Ê∏≤ÊüìÊñπÊ≥ï
        return this.simpleMarkdownRender(md);
      }
    },
    
    // Ê∑ªÂä†‰∏Ä‰∏™ÁÆÄÂçïÁöÑMarkdownÊ∏≤ÊüìÂáΩÊï∞‰Ωú‰∏∫Â§áÁî®
    simpleMarkdownRender(text) {
      if (!text) return "<p></p>";
      
      // ËΩ¨‰πâHTMLÁâπÊÆäÂ≠óÁ¨¶
      let html = text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
      
      // Â§ÑÁêÜ‰ª£Á†ÅÂùó
      html = html.replace(/```([\s\S]*?)```/g, function(match, code) {
        return `<pre><code>${code.trim()}</code></pre>`;
      });
      
      // Â§ÑÁêÜË°åÂÜÖ‰ª£Á†Å
      html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
      
      // Â§ÑÁêÜÁ≤ó‰Ωì
      html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
      html = html.replace(/__([^_]+)__/g, '<strong>$1</strong>');
      
      // Â§ÑÁêÜÊñú‰Ωì
      html = html.replace(/\*([^*]+)\*/g, '<em>$1</em>');
      html = html.replace(/_([^_]+)_/g, '<em>$1</em>');
      
      // Â§ÑÁêÜÈìæÊé•
      html = html.replace(/\[([^\]]+)]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
      
      // Â§ÑÁêÜÊç¢Ë°å
      html = html.replace(/\n/g, '<br>');
      
      return `<div class="simple-markdown">${html}</div>`;
    },
    
    judgeInput(e) {
      if (!e.shiftKey && e.keyCode === 13) {
        e.preventDefault();
        this.send();
      }
    },
    
    handleScrollBottom() {
      this.$nextTick(() => {
        const container = this.$refs.chatContainer;
        if (container) {
          container.scrollTo({
            top: container.scrollHeight,
            behavior: 'smooth'
          });
        }
      });
    },
    
    copyMessage(conv) {
      const text = this.getMessageText(conv);
      navigator.clipboard.writeText(text).then(() => {
        ElMessage.success('Â§çÂà∂ÊàêÂäü');
      });
    },
    
    async toggleRecording() {
      if (this.isRecording) {
        await this.stopRecording();
      } else {
        await this.startRecording();
      }
    },
    
    async startRecording() {
      try {
        // Ê£ÄÊü•ÊµèËßàÂô®ÊîØÊåÅ
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          ElMessage.error('ÊÇ®ÁöÑÊµèËßàÂô®‰∏çÊîØÊåÅÂΩïÈü≥ÂäüËÉΩ');
          return;
        }

        // Â¶ÇÊûúÂ∑≤ÁªèÂú®ÂΩïÈü≥ÔºåÂÖàÂÅúÊ≠¢
        if (this.isRecording) {
          await this.stopRecording();
        }

        // ËØ∑Ê±ÇÈ∫¶ÂÖãÈ£éÊùÉÈôê
        const stream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            sampleRate: 16000,  // Â∞ùËØïËØ∑Ê±Ç16kHzÈááÊ†∑Áéá
            channelCount: 1,    // ÂçïÂ£∞ÈÅì
            echoCancellation: true,
            noiseSuppression: true
          } 
        });
        this.audioStream = stream;
        
        // ÈÖçÁΩÆÂΩïÈü≥ - ÊáíÂä†ËΩΩÂàùÂßãÂåñ
        const recorder = initRecorder();
        
        // Ê∑ªÂä†ÈîôËØØÂ§ÑÁêÜÂíåË∂ÖÊó∂
        const openPromise = new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new Error('ÂΩïÈü≥ËÆæÂ§áÂàùÂßãÂåñË∂ÖÊó∂'));
          }, 5000);
          
          recorder.open(() => {
            clearTimeout(timeout);
            console.log('ÂΩïÈü≥ËÆæÂ§áÂ∑≤Â∞±Áª™');
            resolve();
          }, (err) => {
            clearTimeout(timeout);
            reject(err);
          }, stream); // ‰º†ÂÖ•Â∑≤Ëé∑ÂèñÁöÑÊµÅ
        });
        
        await openPromise;
        
        // ÂºÄÂßãÂΩïÈü≥
        recorder.start();
        this.isRecording = true;
        ElMessage.info('ÂΩïÈü≥Â∑≤ÂºÄÂßã');
        
        // ËÆ∞ÂΩïÂºÄÂßãÊó∂Èó¥Âπ∂ÂêØÂä®ËÆ°Êó∂Âô®
        this.recordingStartTime = Date.now();
        this.recordingTimer = setInterval(() => {
          this.recordingDuration = Math.floor((Date.now() - this.recordingStartTime) / 1000);
          // Â¶ÇÊûúÂΩïÈü≥Ë∂ÖËøá60ÁßíÔºåËá™Âä®ÂÅúÊ≠¢
          if (this.recordingDuration >= 60) {
            this.stopRecording();
            ElMessage.warning('ÂΩïÈü≥Â∑≤ËææÂà∞ÊúÄÂ§ßÊó∂Èïø(60Áßí)');
          }
        }, 1000);
        
      } catch (error) {
        console.error("ÂΩïÈü≥Â§±Ë¥•:", error);
        let errorMsg = "È∫¶ÂÖãÈ£éËÆøÈóÆË¢´ÊãíÁªù";
        if (error.name === 'NotAllowedError') {
          errorMsg = "È∫¶ÂÖãÈ£éËÆøÈóÆÊùÉÈôêË¢´ÊãíÁªùÔºåËØ∑ÂÖÅËÆ∏ÊµèËßàÂô®‰ΩøÁî®È∫¶ÂÖãÈ£é";
        } else if (error.name === 'NotFoundError') {
          errorMsg = "Êú™Ê£ÄÊµãÂà∞È∫¶ÂÖãÈ£éËÆæÂ§á";
        } else if (error.message) {
          errorMsg = error.message;
        }
        ElMessage.error(errorMsg);
        this.closeAudioStream();
      }
    },
    
    async stopRecording() {
      return new Promise((resolve, reject) => {
        // Ê∏ÖÈô§ËÆ°Êó∂Âô®
        if (this.recordingTimer) {
          clearInterval(this.recordingTimer);
          this.recordingTimer = null;
        }
        
        // Â¶ÇÊûúÊ≤°ÊúâÂΩïÈü≥ÂÆû‰æãÊàñÊú™Âú®ÂΩïÈü≥ÔºåÁõ¥Êé•ËøîÂõû
        if (!recorder || !this.isRecording) {
          this.isRecording = false;
          this.closeAudioStream();
          resolve();
          return;
        }
        
        // Ê∑ªÂä†Ë∂ÖÊó∂Â§ÑÁêÜ
        const timeout = setTimeout(() => {
          this.isRecording = false;
          this.closeAudioStream();
          ElMessage.error('ÂΩïÈü≥ÂÅúÊ≠¢Ë∂ÖÊó∂ÔºåËØ∑ÈáçËØï');
          reject(new Error('ÂΩïÈü≥ÂÅúÊ≠¢Ë∂ÖÊó∂'));
        }, 3000);
        
        recorder.stop((blob, duration) => {
          clearTimeout(timeout);
          console.log(`ÂΩïÈü≥ÁªìÊùüÔºåÊó∂Èïø: ${duration}ms`);
          
          // È™åËØÅblobÊòØÂê¶ÊúâÊïà
          if (!blob || blob.size === 0) {
            ElMessage.error('ÂΩïÈü≥Â§±Ë¥•ÔºåÊú™ÊçïËé∑Âà∞Èü≥È¢ë');
            this.isRecording = false;
            this.closeAudioStream();
            reject(new Error('ÂΩïÈü≥Â§±Ë¥•ÔºåÊú™ÊçïËé∑Âà∞Èü≥È¢ë'));
            return;
          }
          
          this.audioBlob = blob;
          this.audioUrl = URL.createObjectURL(blob);
          this.isRecording = false;
          this.recordingDuration = 0;
          ElMessage.success('ÂΩïÈü≥ÂÆåÊàê');
          this.closeAudioStream();
          resolve();
        }, (error) => {
          clearTimeout(timeout);
          console.error('ÂΩïÈü≥ÂÅúÊ≠¢Â§±Ë¥•:', error);
          ElMessage.error('ÂΩïÈü≥ÂÅúÊ≠¢Â§±Ë¥•: ' + (error.message || 'Êú™Áü•ÈîôËØØ'));
          this.isRecording = false;
          this.closeAudioStream();
          reject(error);
        });
      });
    },
    
    closeAudioStream() {
      if (this.audioStream) {
        this.audioStream.getTracks().forEach(track => track.stop());
        this.audioStream = null;
      }
    },
    
    clearRecording() {
      this.audioBlob = null;
      this.audioUrl = null;
      if (this.audioStream) {
        this.closeAudioStream();
      }
    },
    
    // ‰øÆÊîπTokenËé∑ÂèñÊñπÂºè
    getToken() {
      // ‰ªé xm-user ‰∏≠Ëé∑Âèñ tokenÔºå‰∏é request.js ‰øùÊåÅ‰∏ÄËá¥
      const user = JSON.parse(localStorage.getItem("xm-user") || '{}');
      const token = user.token || '';
      
      // Ê£ÄÊü•tokenÊòØÂê¶Â≠òÂú®
      if (!token) {
        console.error('Êú™ÊâæÂà∞ÊúâÊïàÁöÑtokenÔºåÂèØËÉΩÈúÄË¶ÅÈáçÊñ∞ÁôªÂΩï');
        ElMessage.error('ÁôªÂΩïÁä∂ÊÄÅÂ∑≤Â§±ÊïàÔºåËØ∑ÈáçÊñ∞ÁôªÂΩï');
        return null;
      }
      
      return token;
    },
    
    async uploadAudio() {
      if (!this.audioBlob) {
        ElMessage.warning("ËØ∑ÂÖàÂΩïÂà∂Èü≥È¢ë");
        return;
      }

      this.audioUpload = true;

      try {
        // Ê£ÄÊü•ÁôªÂΩïÁä∂ÊÄÅ - ‰ΩøÁî®Áªü‰∏ÄÁöÑ getToken ÊñπÊ≥ï
        const token = this.getToken();
        if (!token) {
          this.audioUpload = false;
          return;
        }

        // Á°Æ‰øùÈü≥È¢ëÊ†ºÂºèÊ≠£Á°Æ
        let processedBlob = this.audioBlob;
        
        // Ê£ÄÊü•Èü≥È¢ëÊ†ºÂºèÔºåÁ°Æ‰øùÊòØWAVÊ†ºÂºè
        if (this.audioBlob.type !== 'audio/wav') {
          ElMessage.info("Ê≠£Âú®Â§ÑÁêÜÈü≥È¢ëÊ†ºÂºè...");
          try {
            processedBlob = await this.ensureCorrectAudioFormat(this.audioBlob);
          } catch (error) {
            console.error("Èü≥È¢ëÊ†ºÂºèËΩ¨Êç¢Â§±Ë¥•:", error);
            ElMessage.warning("Èü≥È¢ëÊ†ºÂºèËΩ¨Êç¢Â§±Ë¥•ÔºåÂ∞Ü‰ΩøÁî®ÂéüÂßãÊ†ºÂºè");
          }
        }
        
        // ÂàõÂª∫FormDataÂØπË±°
        const formData = new FormData();
        formData.append('file', processedBlob, 'recording.wav');

        // ‰ΩøÁî®Áªü‰∏ÄÁöÑËØ∑Ê±ÇÊñπÂºè
        try {
          // Ê≠•È™§1: ÂÖàË∞ÉÁî®Èü≥È¢ëËΩ¨ÂÜôAPI
          ElMessage.info("Ê≠£Âú®ËΩ¨ÂÜôÈü≥È¢ë...");
          
          const transcriptionRes = await post("/files/transcription", formData, {
            headers: { 'Content-Type': 'multipart/form-data' }
          });
          
          if (transcriptionRes.code === '200' && transcriptionRes.data) {
            // ËΩ¨ÂÜôÊàêÂäüÔºåÂ∞ÜÁªìÊûúÊîæÂÖ•ËæìÂÖ•Ê°Ü
            this.chatMsg = transcriptionRes.data;
            ElMessage.success("ËØ≠Èü≥ËΩ¨ÂÜôÊàêÂäü");
            
            // Ê≠•È™§2: ÂÜçË∞ÉÁî®ÊÉÖÁª™ÂàÜÊûêAPI
            ElMessage.info("Ê≠£Âú®ÂàÜÊûêÊÉÖÁª™...");
            
            const emotionFormData = new FormData();
            emotionFormData.append('file', processedBlob, 'recording.wav');
            
            const emotionRes = await post("/business/emotion/analyze", emotionFormData, {
              headers: { 'Content-Type': 'multipart/form-data' }
            });
            
            if (emotionRes.code === '200' && emotionRes.data) {
              // ‰øùÂ≠òÊÉÖÁª™ÂàÜÊûêÁªìÊûú
              this.lastVoiceEmotion = {
                emotion: this.translateEmotion(emotionRes.data.emotion || 'neutral'),
                confidence: emotionRes.data.confidence || '70%',
                quality: this.evaluateAudioQuality(emotionRes.data),
                timestamp: Date.now()
              };
              
              console.log("ÊÉÖÁª™ÂàÜÊûêÁªìÊûú:", this.lastVoiceEmotion);
            }
          } else {
            ElMessage.warning("ËØ≠Èü≥ËΩ¨ÂÜôÂ§±Ë¥•: " + (transcriptionRes.msg || "Êú™Áü•ÈîôËØØ"));
          }
        } catch (error) {
          console.error("‰ΩøÁî®Áªü‰∏ÄËØ∑Ê±ÇÂ∑•ÂÖ∑Â§±Ë¥•:", error);
          ElMessage.error("Èü≥È¢ëÂ§ÑÁêÜÂ§±Ë¥•: " + (error.message || "Êú™Áü•ÈîôËØØ"));
        }
      } catch (error) {
        console.error("Èü≥È¢ë‰∏ä‰º†ÊàñÂ§ÑÁêÜÂá∫Èîô:", error);
        let errorMessage = "Èü≥È¢ëÂ§ÑÁêÜÂ§±Ë¥•";
        if (error.response) {
          errorMessage += `: ${error.response.status} - ${error.response.data?.msg || error.message}`;
        } else if (error.message) {
          errorMessage += ": " + error.message;
        }
        ElMessage.error(errorMessage);
      } finally {
        this.audioUpload = false;
      }
    },
    
    // Ê∑ªÂä†Èü≥È¢ëË¥®ÈáèËØÑ‰º∞ÊñπÊ≥ï
    evaluateAudioQuality(emotionData) {
      // Ê£ÄÊü•ÊòØÂê¶Êúâ‰ø°Âô™ÊØîÊàñÂÖ∂‰ªñÈü≥È¢ëË¥®ÈáèÊåáÊ†á
      if (emotionData.snr !== undefined) {
        // ‰ø°Âô™ÊØî‰Ωé‰∫é10dBËßÜ‰∏∫‰ΩéË¥®Èáè
        return emotionData.snr < 10 ? "low" : "good";
      }
      
      // Â¶ÇÊûúÊ≤°ÊúâÊòéÁ°ÆÁöÑË¥®ÈáèÊåáÊ†áÔºåÊ£ÄÊü•ÊÉÖÁª™Ê¶ÇÁéáÂàÜÂ∏É
      if (emotionData.probabilities) {
        const probs = Object.values(emotionData.probabilities);
        
        // ËÆ°ÁÆóÊ¶ÇÁéáÂàÜÂ∏ÉÁöÑÊ†áÂáÜÂ∑Æ
        const avg = probs.reduce((sum, val) => sum + val, 0) / probs.length;
        const variance = probs.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / probs.length;
        const stdDev = Math.sqrt(variance);
        
        // Â¶ÇÊûúÊ†áÂáÜÂ∑ÆÂæàÂ∞èÔºåËØ¥ÊòéÊ®°ÂûãÂØπÂêÑÊÉÖÁª™ÁöÑÈ¢ÑÊµãÊé•ËøëÔºåÂèØËÉΩÊòØ‰ΩéË¥®ÈáèÈü≥È¢ë
        if (stdDev < 0.1) {
          return "low";
        }
      }
      
      // Ê£ÄÊü•Èü≥È¢ëÊó∂ÈïøÔºåËøáÁü≠ÁöÑÈü≥È¢ëÂèØËÉΩË¥®Èáè‰∏ç‰Ω≥
      if (emotionData.duration !== undefined && emotionData.duration < 1.5) {
        return "low";
      }
      
      // Ê£ÄÊü•Èü≥È¢ëÈü≥Èáè
      if (emotionData.volume !== undefined && emotionData.volume < 0.3) {
        return "low";
      }
      
      // ÈªòËÆ§‰∏∫ËâØÂ•ΩË¥®Èáè
      return "good";
    },
    
    // ÁøªËØëÊÉÖÁª™Ê†áÁ≠æ
    translateEmotion(emotion) {
      const emotionMap = {
        'happy': 'ÂºÄÂøÉ',
        'sad': 'ÊÇ≤‰º§',
        'angry': 'ÊÑ§ÊÄí',
        'fear': 'ÊÅêÊÉß',
        'disgust': 'ÂéåÊÅ∂',
        'neutral': 'Âπ≥Èùô',
        'surprise': 'ÊÉäËÆ∂',
        'anxiety': 'ÁÑ¶Ëôë',
        'depression': 'ÊäëÈÉÅ',
        'confusion': 'Âõ∞ÊÉë',
        'stress': 'ÂéãÂäõ'
      };
      
      return emotionMap[emotion] || emotion;
    },
    
    async analyzeEmotion() {
      if (this.convLoading) return;
      
      // Ëé∑ÂèñÊúÄËøë3Êù°Áî®Êà∑Ê∂àÊÅØ
      const lastHumanMessages = this.getCurrentConversation
        .filter(msg => msg.speaker === 'human')
        .slice(-3)
        .map(msg => msg.speech)
        .join("\n");
      
      if (!lastHumanMessages) {
        ElMessage.warning("ËØ∑ÂÖà‰∏éAIÂØπËØùÂêéÂÜçÂàÜÊûêÊÉÖÁª™");
        return;
      }
      
      // Ê£ÄÊü•ÊòØÂê¶ÊúâÊúÄËøëÁöÑËØ≠Èü≥ÊÉÖÁª™ÂàÜÊûêÁªìÊûú
      let emotionContext = "";
      if (this.lastVoiceEmotion && 
          (Date.now() - this.lastVoiceEmotion.timestamp < 5 * 60 * 1000)) {
        emotionContext = `
        Ê≥®ÊÑèÔºöÁî®Êà∑ÊúÄËøëÁöÑËØ≠Èü≥ÊÉÖÁª™ÂàÜÊûêÁªìÊûú‰∏∫"${this.lastVoiceEmotion.emotion}"Ôºå
        ÁΩÆ‰ø°Â∫¶‰∏∫${this.lastVoiceEmotion.confidence}„ÄÇËØ∑Â∞ÜÊ≠§‰ø°ÊÅØ‰Ωú‰∏∫ÈáçË¶ÅÂèÇËÄÉ„ÄÇ`;
      }
      
      const prompt = `ËØ∑Ê†πÊçÆÁî®Êà∑ÊúÄËøëÁöÑÂØπËØùÂÜÖÂÆπÂàÜÊûêÂÖ∂ÊÉÖÁª™Áä∂ÊÄÅ„ÄÇÂØπËØùÂÜÖÂÆπÂ¶Ç‰∏ãÔºö
      ${lastHumanMessages}${emotionContext}
      
      ËØ∑Áî®‰ª•‰∏ãÊ†ºÂºèÂõûÂ§çÔºö
      „ÄêÊÉÖÁª™ÂàÜÊûêÁªìÊûú„Äë
      ÊÇ®ÁöÑÂΩìÂâçÊÉÖÁª™‰∏ªË¶ÅÊòØÔºö{ÊÉÖÁª™Á±ªÂûã}
      ÊÉÖÁª™Âº∫Â∫¶Ôºö{‰Ωé/‰∏≠/È´ò}
      „ÄêËØ¶ÁªÜÂàÜÊûê„Äë
      {ÁÆÄË¶ÅÂàÜÊûêÁî®Êà∑ÊÉÖÁª™Áä∂ÊÄÅÁöÑÂéüÂõ†ÂíåË°®Áé∞}
      „ÄêÂª∫ËÆÆ„Äë
      {Ê†πÊçÆÊÉÖÁª™Áä∂ÊÄÅÁªôÂá∫1-2Êù°ÁÆÄÂçïÁöÑËá™ÊàëË∞ÉËäÇÂª∫ËÆÆ}
      ÊÉÖÁª™Á±ªÂûãËØ∑‰ªé‰ª•‰∏ãÈÄâÈ°π‰∏≠ÈÄâÊã©ÔºöÂºÄÂøÉ„ÄÅÂπ≥Èùô„ÄÅÁÑ¶Ëôë„ÄÅÊÑ§ÊÄí„ÄÅÊÇ≤‰º§„ÄÅÂõ∞ÊÉë„ÄÅÂéãÂäõ„ÄÅÂÖ∂‰ªñ`;
      
      try {
        ElMessage.info("Ê≠£Âú®ÂàÜÊûêÊÉÖÁª™...");
        await this.sendMessageWithRetry(prompt);
      } catch (error) {
        console.error("ÊÉÖÁª™ÂàÜÊûêÂ§±Ë¥•:", error);
        ElMessage.error("ÊÉÖÁª™ÂàÜÊûêËØ∑Ê±ÇÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÂÜçËØï");
      }
    },
    
    adjustTextareaHeight() {
      const textarea = this.$refs.inputChat;
      if (textarea) {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
      }
    },
    
    focusInput() {
      this.$nextTick(() => {
        const textarea = this.$refs.inputChat;
        if (textarea) {
          textarea.focus();
        }
      });
    },
    
    // Â¢ûÂº∫ÁΩëÁªúÁä∂ÊÄÅÊ£ÄÊü•ÊñπÊ≥ï
    checkNetworkStatus() {
      if (!navigator.onLine) {
        ElMessage.error("ÁΩëÁªúËøûÊé•Â∑≤Êñ≠ÂºÄÔºåËØ∑Ê£ÄÊü•ÊÇ®ÁöÑÁΩëÁªúËÆæÁΩÆ");
        return false;
      }
      
      // Ê∑ªÂä†È¢ùÂ§ñÁöÑÁΩëÁªúÊ£ÄÊµãÈÄªËæë
      if (this.lastNetworkCheckFailed) {
        // Â¶ÇÊûú‰∏äÊ¨°ÁΩëÁªúÊ£ÄÊü•Â§±Ë¥•ÔºåËøõË°åÊõ¥‰∏•Ê†ºÁöÑÊ£ÄÊü•
        return this.performDeepNetworkCheck();
      }
      
      return true;
    },
    
    // Ê∑ªÂä†Ê∑±Â∫¶ÁΩëÁªúÊ£ÄÊü•ÊñπÊ≥ï
    async performDeepNetworkCheck() {
      try {
        // ‰ΩøÁî®Â∑≤Â≠òÂú®ÁöÑÂêéÁ´ØÊé•Âè£ËøõË°åÊ£ÄÊü•
        const response = await fetch(`${import.meta.env.VITE_APP_BASE_API}/health`, { 
          method: 'HEAD',
          cache: 'no-store',
          timeout: 2000
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        this.lastNetworkCheckFailed = false;
        return true;
      } catch (error) {
        console.error('Ê∑±Â∫¶ÁΩëÁªúÊ£ÄÊü•Â§±Ë¥•:', error);
        this.lastNetworkCheckFailed = true;
        ElMessage.error('ÁΩëÁªúËøûÊé•‰∏çÁ®≥ÂÆöÔºåËØ∑Ê£ÄÊü•ÊÇ®ÁöÑÁΩëÁªúËÆæÁΩÆ');
        return false;
      }
    },
    
    // Ê∑ªÂä†ÈáçËØïÂäüËÉΩ
    async sendMessageWithRetry(msg, retryCount = 0) {
      const maxRetries = 2; // ÊúÄÂ§ßÈáçËØïÊ¨°Êï∞
      
      try {
        await this.sendMessage(msg);
      } catch (error) {
        console.error(`ÂèëÈÄÅÊ∂àÊÅØÂ§±Ë¥• (Â∞ùËØï ${retryCount + 1}/${maxRetries + 1})`, error);
        
        if (retryCount < maxRetries && navigator.onLine) {
          // Â¶ÇÊûúÁΩëÁªúÂú®Á∫ø‰∏îÊú™Ë∂ÖËøáÊúÄÂ§ßÈáçËØïÊ¨°Êï∞ÔºåÂàôÈáçËØï
          ElMessage.info(`Ê≠£Âú®ÈáçËØï (${retryCount + 1}/${maxRetries})...`);
          await new Promise(resolve => setTimeout(resolve, 1000)); // Á≠âÂæÖ1ÁßíÂêéÈáçËØï
          await this.sendMessageWithRetry(msg, retryCount + 1);
        } else {
          // Ë∂ÖËøáÈáçËØïÊ¨°Êï∞ÊàñÁΩëÁªúÁ¶ªÁ∫øÔºåÊòæÁ§∫ÊúÄÁªàÈîôËØØ
          ElMessage.error('ÂèëÈÄÅÊ∂àÊÅØÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•ÂêéÈáçËØï');
        }
      }
    },
    
    extractTextFromResponse(data) {
      // Â§ÑÁêÜnull/undefined
      if (data == null) return "ÊúçÂä°Âô®ËøîÂõû‰∫ÜÁ©∫ÂìçÂ∫î";
      
      // Â§ÑÁêÜÂ≠óÁ¨¶‰∏≤
      if (typeof data === 'string') {
        // Ê£ÄÊü•ÊòØÂê¶ÊòØJSONÂ≠óÁ¨¶‰∏≤
        if (data.trim().startsWith('{') || data.trim().startsWith('[')) {
          try {
            const parsed = JSON.parse(data);
            return this.extractTextFromResponse(parsed);
          } catch {
            return data; // ËøîÂõûÂéüÂßãÂ≠óÁ¨¶‰∏≤
          }
        }
        return data;
      }
      
      // Â§ÑÁêÜÊï∞ÁªÑ
      if (Array.isArray(data)) {
        // Â∞ùËØïÊèêÂèñÁ¨¨‰∏Ä‰∏™ÂÖÉÁ¥†ÁöÑcontent/message/textÂ≠óÊÆµ
        if (data.length > 0) {
          const firstItem = data[0];
          if (typeof firstItem === 'object' && firstItem !== null) {
            if (firstItem.content) return firstItem.content;
            if (firstItem.message?.content) return firstItem.message.content;
            if (firstItem.message) return typeof firstItem.message === 'string' ? firstItem.message : JSON.stringify(firstItem.message);
            if (firstItem.text) return firstItem.text;
          } else if (typeof firstItem === 'string') {
            return firstItem;
          }
        }
        return data.map(item => this.extractTextFromResponse(item)).join('\n');
      }
      
      // Â§ÑÁêÜÂØπË±°
      if (typeof data === 'object') {
        // DeepSeekÊ†áÂáÜÂ≠óÊÆµ
        if (data.content) return data.content;
        if (data.message?.content) return data.message.content;
        if (data.message && typeof data.message === 'string') return data.message;
        if (data.text) return data.text;
        
        // OpenAIÂÖºÂÆπÊ†ºÂºè
        if (data.choices && Array.isArray(data.choices) && data.choices.length > 0) {
          const choice = data.choices[0];
          if (choice.message?.content) return choice.message.content;
          if (choice.text) return choice.text;
          if (choice.message) return typeof choice.message === 'string' ? choice.message : JSON.stringify(choice.message);
          if (choice.delta?.content) return choice.delta.content;
          return this.extractTextFromResponse(choice);
        }
        
        // Â∞ùËØïÊèêÂèñÁ¨¨‰∏Ä‰∏™Â±ûÊÄßÂÄº
        const keys = Object.keys(data);
        if (keys.length > 0) {
          const firstValue = data[keys[0]];
          if (firstValue !== undefined) {
            return this.extractTextFromResponse(firstValue);
          }
        }
        
        // ÊúÄÂêéÂ∞ùËØïJSONÊ†ºÂºèÂåñ
        try {
          return "```json\n" + JSON.stringify(data, null, 2) + "\n```";
        } catch {
          return "Êó†Ê≥ïËß£ÊûêÁöÑÂìçÂ∫îÊï∞ÊçÆ";
        }
      }
      
      // ÂÖ∂‰ªñÁ±ªÂûãËΩ¨Êç¢‰∏∫Â≠óÁ¨¶‰∏≤
      return String(data);
    },
    
    handleNetworkChange() {
      this.networkStatus = navigator.onLine;
      if (navigator.onLine) {
        ElMessage.success('ÁΩëÁªúÂ∑≤ËøûÊé•');
      } else {
        ElMessage.error('ÁΩëÁªúÂ∑≤Êñ≠ÂºÄ');
      }
    },
    
    // Âú®methods‰∏≠Ê∑ªÂä†Ë∞ÉËØïÂáΩÊï∞
    debugConversation() {
      //console.log("ÂΩìÂâçÂØπËØùÊï∞ÊçÆÁªìÊûÑ:", JSON.stringify(this.getCurrentConversation, null, 2));
      
      // Ê£ÄÊü•ÊúÄÂêé‰∏ÄÊù°Ê∂àÊÅØ
      if (this.getCurrentConversation && this.getCurrentConversation.length > 0) {
        const lastMsg = this.getCurrentConversation[this.getCurrentConversation.length - 1];
        //console.log("ÊúÄÂêé‰∏ÄÊù°Ê∂àÊÅØ:", lastMsg);
        //console.log("speechesÁ±ªÂûã:", lastMsg.speeches ? typeof lastMsg.speeches : "undefined");
        if (lastMsg.speeches) {
          //console.log("speeches[0]Á±ªÂûã:", typeof lastMsg.speeches[0]);
          //console.log("speeches[0]ÂÄº:", lastMsg.speeches[0]);
        }
      }
    },
    
    getMessageText(conv) {
      if (!conv) {
        console.warn("getMessageText: Êî∂Âà∞Á©∫ÁöÑÂØπËØùÂØπË±°");
        return "";
      }
      
      console.log("getMessageTextÂ§ÑÁêÜÂØπË±°:", conv);
      
      // ÂØπ‰∫éAIÊ∂àÊÅØÔºåÂ∞ùËØïÂ§öÁßçÂèØËÉΩÁöÑÊï∞ÊçÆÁªìÊûÑ
      if (conv.speaker === 'ai') {
        // È¶ñÂÖàÊ£ÄÊü•speechesÊï∞ÁªÑ
        if (Array.isArray(conv.speeches) && conv.speeches.length > 0) {
         // console.log("‰ΩøÁî®speeches[0]:", conv.speeches[0]);
          if (typeof conv.speeches[0] === 'string') {
            return conv.speeches[0];
          } else if (conv.speeches[0] && typeof conv.speeches[0] === 'object') {
            const jsonStr = JSON.stringify(conv.speeches[0]);
           // console.log("speeches[0]ÊòØÂØπË±°ÔºåËΩ¨Êç¢‰∏∫JSON:", jsonStr);
            return jsonStr;
          }
        }
        
        // ÁÑ∂ÂêéÊ£ÄÊü•speechÂ≠óÊÆµ
        if (conv.speech && typeof conv.speech === 'string') {
          //console.log("‰ΩøÁî®speechÂ≠óÊÆµ:", conv.speech);
          return conv.speech;
        }
        
        // ÊúÄÂêéÂ∞ùËØïÂÖ∂‰ªñÂèØËÉΩÁöÑÂ≠óÊÆµ
        if (conv.content && typeof conv.content === 'string') {
          //console.log("‰ΩøÁî®contentÂ≠óÊÆµ:", conv.content);
          return conv.content;
        }
        
        console.warn("Êó†Ê≥ïÊâæÂà∞ÊúâÊïàÁöÑÊ∂àÊÅØÂÜÖÂÆπ");
        return "Êó†Ê≥ïÊòæÁ§∫Ê∂àÊÅØÂÜÖÂÆπ";
      }
      
      // ÂØπ‰∫éÁî®Êà∑Ê∂àÊÅØÔºåÁõ¥Êé•ËøîÂõûspeech
      return conv.speech || "";
    },
    
    async ensureCorrectAudioFormat(blob) {
      // Â¶ÇÊûúÂ∑≤ÁªèÊòØÊ≠£Á°ÆÊ†ºÂºèÔºåÁõ¥Êé•ËøîÂõû
      if (blob.type === 'audio/wav') {
        return blob;
      }
      
      // Âê¶ÂàôÂ∞ùËØïËΩ¨Êç¢
      return new Promise((resolve, reject) => {
        try {
          const fileReader = new FileReader();
          fileReader.onload = (event) => {
            const arrayBuffer = event.target.result;
            
            // ‰ΩøÁî®AudioContextËøõË°åÊ†ºÂºèËΩ¨Êç¢
            const audioContext = new (window.AudioContext || window.webkitAudioContext)({
              sampleRate: 16000 // Âº∫Âà∂‰ΩøÁî®16kHzÈááÊ†∑Áéá
            });
            
            audioContext.decodeAudioData(arrayBuffer, (buffer) => {
              // ÂàõÂª∫Á¶ªÁ∫ø‰∏ä‰∏ãÊñáËøõË°åÈáçÈááÊ†∑
              const offlineContext = new OfflineAudioContext(
                1, // ÂçïÂ£∞ÈÅì
                buffer.duration * 16000, // Êñ∞ÁöÑÈááÊ†∑Áéá‰∏ãÁöÑÊ†∑Êú¨Êï∞
                16000 // ÁõÆÊ†áÈááÊ†∑Áéá
              );
              
              const source = offlineContext.createBufferSource();
              source.buffer = buffer;
              source.connect(offlineContext.destination);
              source.start(0);
              
              offlineContext.startRendering().then((renderedBuffer) => {
                // Â∞ÜAudioBufferËΩ¨Êç¢‰∏∫WAVÊ†ºÂºè
                const wavBlob = this.bufferToWav(renderedBuffer);
                resolve(new Blob([wavBlob], { type: 'audio/wav' }));
              }).catch((err) => {
                console.error('Èü≥È¢ëÊ∏≤ÊüìÂ§±Ë¥•:', err);
                reject(err);
              });
            }, (err) => {
              console.error('Èü≥È¢ëËß£Á†ÅÂ§±Ë¥•:', err);
              reject(err);
            });
          };
          
          fileReader.onerror = function(error) {
            reject(error);
          };
          
          fileReader.readAsArrayBuffer(blob);
        } catch (error) {
          console.error('Èü≥È¢ëÊ†ºÂºèËΩ¨Êç¢Â§±Ë¥•:', error);
          reject(error);
        }
      });
    },
    
    // ËæÖÂä©ÂáΩÊï∞ÔºöÂ∞ÜAudioBufferËΩ¨Êç¢‰∏∫WAVÊ†ºÂºè
    bufferToWav(buffer) {
      const numOfChan = buffer.numberOfChannels;
      const length = buffer.length * numOfChan * 2;
      const result = new ArrayBuffer(44 + length);
      const view = new DataView(result);
      
      // RIFFÊ†áËØÜ
      this.writeString(view, 0, 'RIFF');
      // RIFFÂùóÈïøÂ∫¶
      view.setUint32(4, 36 + length, true);
      // WAVEÊ†áËØÜ
      this.writeString(view, 8, 'WAVE');
      // fmtÊ†áËØÜ
      this.writeString(view, 12, 'fmt ');
      // fmtÂùóÈïøÂ∫¶
      view.setUint32(16, 16, true);
      // ÈááÊ†∑Ê†ºÂºèÔºàPCMÔºâ
      view.setUint16(20, 1, true);
      // Â£∞ÈÅìÊï∞
      view.setUint16(22, numOfChan, true);
      // ÈááÊ†∑Áéá
      view.setUint32(24, buffer.sampleRate, true);
      // ÊØèÁßíÂ≠óËäÇÊï∞
      view.setUint32(28, buffer.sampleRate * 2 * numOfChan, true);
      // ÊØèÊ†∑Êú¨Â≠óËäÇÊï∞
      view.setUint16(32, numOfChan * 2, true);
      // ‰ΩçÊ∑±Â∫¶
      view.setUint16(34, 16, true);
      // dataÊ†áËØÜ
      this.writeString(view, 36, 'data');
      // dataÂùóÈïøÂ∫¶
      view.setUint32(40, length, true);
      
      // ÂÜôÂÖ•PCMÊï∞ÊçÆ
      const channelData = [];
      let offset = 44;
      for (let i = 0; i < buffer.numberOfChannels; i++) {
        channelData.push(buffer.getChannelData(i));
      }
      
      // ‰ΩøÁî®Êõ¥ÂÆâÂÖ®ÁöÑÁ¥¢ÂºïËÆ°ÁÆóÊñπÂºè
      const dataLength = buffer.length;
      for (let i = 0; i < dataLength; i++) {
        for (let channel = 0; channel < numOfChan; channel++) {
          if (offset < result.byteLength) {
            const sample = Math.max(-1, Math.min(1, channelData[channel][i]));
            view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
            offset += 2;
          }
        }
      }
      
      return result;
    },
    
    // ËæÖÂä©ÂáΩÊï∞ÔºöÂÜôÂÖ•Â≠óÁ¨¶‰∏≤
    writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    },
    
    // Ê∑ªÂä† Markdown ÂÆâÂÖ®ËøáÊª§ÊñπÊ≥ï
    sanitizeMarkdown(md) {
      // ÁßªÈô§ÊΩúÂú®ÁöÑÂç±Èô©HTMLÊ†áÁ≠æ
      md = md.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
      md = md.replace(/<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi, '');
      md = md.replace(/<embed\b[^<]*(?:(?!<\/embed>)<[^<]*)*<\/embed>/gi, '');
      md = md.replace(/<object\b[^<]*(?:(?!<\/object>)<[^<]*)*<\/object>/gi, '');
      
      // ËøáÊª§ÂèØËÉΩÁöÑXSSÊîªÂáªÂêëÈáè
      md = md.replace(/javascript:/gi, 'javascript:void(0);');
      md = md.replace(/data:/gi, 'data:void(0);');
      
      return md;
    },
  },
  async mounted() {
    await this.init();
    // Á°Æ‰øù‰ª£Á†ÅÈ´ò‰∫Æ - Âª∂ËøüÂä†ËΩΩ
    setTimeout(() => {
      if (typeof hljs !== 'undefined') {
        hljs.highlightAll();
      }
    }, 100);
    
    // ÂàùÂßãÊªöÂä®Âà∞Â∫ïÈÉ®
    this.handleScrollBottom();
    
    // ‰ΩøÁî®Èò≤Êäñ‰ºòÂåñÁ™óÂè£Â§ßÂ∞èÂèòÂåñ‰∫ã‰ª∂
    let resizeTimeout;
    const handleResizeWithDebounce = () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(this.handleScrollBottom, 100);
    };
    
    window.addEventListener('resize', handleResizeWithDebounce);
    
    // ÂàùÂßãÂåñËæìÂÖ•Ê°ÜÈ´òÂ∫¶
    this.$nextTick(() => {
      this.adjustTextareaHeight();
      
      // Ê∑ªÂä†ÁÇπÂáª‰∫ã‰ª∂ÁõëÂê¨Âô®
      document.addEventListener('click', (e) => {
        // Â¶ÇÊûúÁÇπÂáªÁöÑÊòØËæìÂÖ•Ê°ÜÂå∫ÂüüÔºåÁ°Æ‰øùËæìÂÖ•Ê°ÜËé∑ÂæóÁÑ¶ÁÇπ
        if (e.target.closest('.input-container')) {
          this.focusInput();
        }
      });
    });
    
    // ÁõëÂê¨ÁΩëÁªúÁä∂ÊÄÅÂèòÂåñ
    window.addEventListener('online', this.handleNetworkChange);
    window.addEventListener('offline', this.handleNetworkChange);
    
    // Ê∑ªÂä†storeÁõëÂê¨
    this.$store.subscribe((mutation, state) => {
      if (mutation.type === 'ADD_CONVERSATION_CONTENT') {
        console.log("StoreÊõ¥Êñ∞:", mutation.payload);
        // Âº∫Âà∂ÈáçÊñ∞Ê∏≤Êüì
        this.$forceUpdate();
      }
    });
    
    // Ê∑ªÂä†ÂÆöÊúüÊ∏ÖÁêÜÁºìÂ≠òÁöÑÈÄªËæë
    this.cacheCleanupInterval = setInterval(() => {
      // Â¶ÇÊûúÁºìÂ≠òËøáÂ§ßÔºåÊ∏ÖÁêÜ‰∏ÄÂçä
      if (mdCache.size > MAX_CACHE_SIZE / 2) {
        const keysToDelete = Array.from(mdCache.keys()).slice(0, mdCache.size / 2);
        keysToDelete.forEach(key => mdCache.delete(key));
        console.log(`Â∑≤Ê∏ÖÁêÜ ${keysToDelete.length} ‰∏™MarkdownÁºìÂ≠òÈ°π`);
      }
      
      if (rendererCache.size > MAX_CACHE_SIZE / 2) {
        const keysToDelete = Array.from(rendererCache.keys()).slice(0, rendererCache.size / 2);
        keysToDelete.forEach(key => rendererCache.delete(key));
        console.log(`Â∑≤Ê∏ÖÁêÜ ${keysToDelete.length} ‰∏™Ê∏≤ÊüìÂô®ÁºìÂ≠òÈ°π`);
      }
    }, 60000); // ÊØèÂàÜÈíüÊ£ÄÊü•‰∏ÄÊ¨°
    
    // ÂàùÂßãÂåñ API Âü∫Á°Ä URL - ‰ΩøÁî®ÁéØÂ¢ÉÂèòÈáè
    this.apiBaseUrl = import.meta.env.VITE_APP_BASE_API || '';
    
    // Â¶ÇÊûúÊòØÁîü‰∫ßÁéØÂ¢ÉÔºåÂèØ‰ª•‰ΩøÁî®Á©∫Â≠óÁ¨¶‰∏≤ÔºàÁõ∏ÂØπË∑ØÂæÑÔºâ
    if (import.meta.env.PROD) {
      this.apiBaseUrl = ''; // Áîü‰∫ßÁéØÂ¢É‰ΩøÁî®Áõ∏ÂØπË∑ØÂæÑ
    }
    
    console.log('‰ΩøÁî® API Âü∫Á°Ä URL:', this.apiBaseUrl);
  },
  beforeUnmount() {
    if (this.isRecording) {
      this.stopRecording();
    }
    this.closeAudioStream();
    
    // ÁßªÈô§‰∫ã‰ª∂ÁõëÂê¨
    window.removeEventListener('resize', this.handleScrollBottom);
    
    // Ê∏ÖÁêÜÂÆöÊó∂Âô®
    if (this.cacheCleanupInterval) {
      clearInterval(this.cacheCleanupInterval);
    }
    
    if (this.recordingTimer) {
      clearInterval(this.recordingTimer);
    }
    
    // Ê∏ÖÁêÜÁºìÂ≠ò
    rendererCache.clear();
    mdCache.clear();
    
    // ÁßªÈô§ÁΩëÁªúÁä∂ÊÄÅÁõëÂê¨
    window.removeEventListener('online', this.handleNetworkChange);
    window.removeEventListener('offline', this.handleNetworkChange);
  },
  watch: {
    chatMsg() {
      this.adjustTextareaHeight();
    }
  }
}
</script>

<style scoped lang="scss">
.chat-wrapper {
  display: flex;
  flex-direction: column;
  height: 100% !important;
  width: 100% !important;
  background-color: #f9fafb;
  position: relative;
  
  header {
    flex-shrink: 0;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    width: 100%;
  }
  
  main {
    flex: 1;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    width: 100%;
    position: relative;
  }
}

.message-wrapper {
  display: flex;
  width: 100%;
  margin-bottom: 16px;
}

.message-bubble {
  display: flex;
  gap: 12px;
  max-width: 85%;
  
  &.ai {
    .message-content {
      background-color: #f0f7ff;
      border: 1px solid #d1e3f8;
      border-radius: 0 16px 16px 16px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
      color: #1e3a5f;
    }
    
    .avatar {
      order: 1;
    }
    
    .message-content {
      order: 2;
    }
  }
  
  &.human {
    margin-left: auto;
    
    .message-content {
      background-color: #edf7ed;
      color: #1e3a1e;
      border: 1px solid #c6e6c6;
      border-radius: 16px 0 16px 16px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }
    
    .avatar {
      order: 2;
    }
    
    .message-content {
      order: 1;
    }
    
    .message-actions {
      justify-content: flex-end;
    }
  }
  
  .avatar {
    flex-shrink: 0;
    display: flex;
    align-items: flex-start;
    padding-top: 4px;
  }
  
  .message-content {
    flex: 1;
    min-width: 0;
    padding: 12px 16px;
    position: relative;
    transition: all 0.2s ease;
    
    &:hover {
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      
      .message-actions {
        opacity: 1;
      }
    }
  }
  
  .message-body {
    word-break: break-word;
    line-height: 1.6;
    
    pre, code {
      white-space: pre-wrap;
      word-break: break-all;
    }
    
    a {
      word-break: break-all;
    }
  }
  
  .message-actions {
    position: absolute;
    top: 8px;
    right: 8px;
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: opacity 0.2s;
    
    .action-icon {
      color: #6b7280;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 4px;
      padding: 2px;
      cursor: pointer;
      
      &:hover {
        color: #1890ff;
        background: rgba(255, 255, 255, 0.95);
      }
    }
  }
  
  &.loading {
    .message-content {
      background: none;
      border: none;
      box-shadow: none;
    }
  }
}

.input-container {
  display: flex;
  gap: 8px;
  margin-bottom: 12px;
  position: relative;
  z-index: 10;
  width: 100%;
}

.typing-indicator {
  display: flex;
  gap: 6px;
  padding: 12px 16px;
  background-color: #f0f7ff;
  border-radius: 12px;
  
  span {
    width: 8px;
    height: 8px;
    background-color: #4b83c5;
    border-radius: 50%;
    display: inline-block;
    animation: typing 1s infinite ease-in-out;
    
    &:nth-child(2) {
      animation-delay: 0.2s;
    }
    
    &:nth-child(3) {
      animation-delay: 0.4s;
    }
  }
}

@keyframes typing {
  0%, 100% {
    transform: translateY(0);
    opacity: 0.6;
  }
  50% {
    transform: translateY(-4px);
    opacity: 1;
  }
}

.welcome-message {
  transition: all 0.3s ease;
  
  &:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    transform: translateY(-1px);
  }
}

.audio-preview {
  background-color: #f0f7ff;
  border: 1px solid #d1e3f8;
  transition: all 0.2s ease;
  
  &:hover {
    background-color: #e0f2fe;
  }
  
  audio {
    border-radius: 4px;
  }
}

.chat-input {
  min-height: 48px;
  max-height: 120px;
  line-height: 1.5;
  transition: all 0.2s;
  
  &:focus {
    outline: none;
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
  }
}

.send-button {
  &:disabled {
    opacity: 0.7;
  }
  
  &:not(:disabled):hover {
    transform: scale(1.05);
  }
}

.tool-button {
  &:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
  
  &:not(:disabled):hover {
    transform: translateY(-1px);
  }
}

.recording-indicator {
  margin-left: 4px;
}

.code-block {
  max-height: 300px;
  overflow-y: auto;
}

/* ÂÖ®Â±ÄÊåâÈíÆÊ†∑Âºè */
:global(.btn) {
  @apply rounded-md transition-all duration-200 flex items-center justify-center;
  
  &:not(:disabled):hover {
    @apply transform -translate-y-0.5 shadow-md;
  }
  
  &:disabled {
    @apply opacity-70 cursor-not-allowed;
  }
}

:global(.btn-primary) {
  @apply bg-[#4a9be6] hover:bg-[#7c97ea] text-white;
}

:global(.btn-secondary) {
  @apply bg-gray-100 hover:bg-gray-200 text-gray-700;
}

:global(.btn-danger) {
  @apply bg-red-500 hover:bg-red-600 text-white;
}

:global(.btn-success) {
  @apply bg-green-600 hover:bg-green-700 text-white;
}

:global(.btn-icon) {
  @apply p-2 rounded-full transition-all duration-200;
  
  &:hover {
    @apply transform -translate-y-0.5;
  }
}

:global(.btn-icon-danger) {
  @apply text-red-500 hover:bg-red-50;
}

:global(.btn-icon-primary) {
  @apply text-[#2A5C8A] hover:bg-blue-50;
}
</style>